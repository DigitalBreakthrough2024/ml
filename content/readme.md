# Content Filtration
---
### Обзор

Данный подпроект посвящен системе рекомендаций видео на основе контентной фильтрации. Система ранжирует видео на основе их метаданных, таких как количество просмотров и дата публикации, а также вычисляет сходство между вектором интересов пользователя и эмбеддингами видео. Вектор интересов пользователя динамически обновляется на основе обратной связи (лайков/дизлайков), что позволяет улучшать рекомендации с течением времени.

## Основные функции

- **Контентная фильтрация**: Рекомендации видео осуществляются с использованием косинусного сходства между вектором интересов пользователя и эмбеддингами видео (заголовок, описание и категория).
- **Ранжирование по просмотрам и свежести**: Видео сортируются по общему количеству просмотров, долгим просмотрам за последнюю неделю и свежести публикации.
- **Динамическое обновление вектора интересов пользователя**: Вектор интересов обновляется на основе обратной связи с использованием градиентного метода.
- **Вычисление косинусного сходства**: Находит наиболее релевантные видео, сравнивая эмбеддинги видео с вектором интересов пользователя и ранжируя их по сходству.

## Структура файлов

- **content_model.py**: Основной скрипт, содержащий функции для обработки данных, ранжирования видео, обновления вектора пользователя и вычисления косинусного сходства.
- **video_stat_50k_emb.csv**: Пример датасета с 50,000 видео и их метаданными и эмбеддингами.

## Установка

1. Клонируйте этот репозиторий на локальную машину.
2. Убедитесь, что у вас установлен Python версии 3.8+.
3. Установите необходимые зависимости с помощью `pip`:
   ```bash
   pip install -r requirements.txt
   ```

## Как это работает
1. Загрузка и обработка данных

```python
df_stat = load_and_process_data('video_stat_50k_emb.csv')
```

Эта функция загружает и обрабатывает данные о видео, преобразуя эмбеддинги из строкового формата в списки.
2. Ранжирование видео

```python
top_10_videos = rank_videos(df_stat)
```

Функция ранжирует видео на основе общего количества просмотров, недавних просмотров и свежести, выводя топ-10 релевантных видео.
3. Обновление вектора интересов пользователя

```python
updated_user_vector = update_interest_vector(user_vector, video_vector, feedback)
```

Функция обновляет вектор интересов пользователя, используя градиентное обновление на основе обратной связи (лайк/дизлайк).
4. Поиск наиболее похожих видео

```python
closest_videos = find_closest_videos(user_vector, df_stat)
```

Находит топ N видео, наиболее близких к вектору интересов пользователя, с помощью вычисления косинусного сходства.
5. Основной рабочий процесс

```python
def main(user_vector, video_ids, feedback, df_stat):
    video_pool, updated_user_vector = main(user_vector, video_ids, feedback, df_stat)
```

Основная функция, которая объединяет ранжирование, косинусное сходство и обновление вектора. Она принимает обратную связь и список идентификаторов видео на вход, возвращая отсортированный пул видео и обновленный вектор интересов пользователя.
Пример использования

```python
# Пример использования основной функции
user_vector = np.array([0.5] * len(df_stat['combined_embedding'][0]))
video_ids = ['video_1', 'video_2', 'video_3']
feedback = [1, -1, 0]  # Оценки видео: 1 = лайк, -1 = дизлайк, 0 = нейтрально

video_pool, updated_user_vector = main(user_vector, video_ids, feedback, df_stat)
```
